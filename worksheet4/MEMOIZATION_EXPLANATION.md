# Knapsack Algorithm Versions - Explanation

## **Version 1 (knapsack_v1.py) - Generate All Combinations**

```
                    comb(0) x=[]
                    /              \
              x[0]=0                x[0]=1
              comb(1)                comb(1)
             /      \               /      \
        x[1]=0   x[1]=1       x[1]=0   x[1]=1
        comb(2)  comb(2)      comb(2)  comb(2)
          ...      ...          ...      ...
        
At leaf (i=N): Check if total weight ≤ M, return total value or -1
```

- **Generates**: All 2^N combinations (e.g., [0,0,1], [1,0,1], etc.)
- **Calls**: 2^(N+1) - 1 function calls
- **Problem**: Evaluates ALL combinations, even invalid ones

---

## **Version 2 (knapsack_v2.py) - Brute Force with Pruning**

```
                maxVal(0, C=100)
                /              \
          skip item 0      take item 0
        maxVal(1, C=100)   maxVal(1, C=100-w[0])
           /      \            /         \
       skip 1   take 1     skip 1     take 1
    maxVal(2,C) maxVal(2,C-w[1]) maxVal(2,C-w[0]) maxVal(2,C-w[0]-w[1])
    
PROBLEM: Same states can be reached via different paths!
Example: skip(0)->take(1) and take(1)->skip(0) both reach (2, C-w[1])
```

- **State**: `(i, C)` = "items from i onward, with capacity C"
- **Calls**: Exponential but prunes impossible branches early
- **Problem**: **RECOMPUTES the same (i, C) states multiple times**

### Why are states repeated?

Different paths can lead to the same state:
- Path A: Skip item 0 (w=10) → Take item 1 (w=15) → State: (2, 75)
- Path B: Take item 1 (w=15) → Skip item 0 (w=10) → State: (2, 75)

Both paths end at the same state but v2 computes it twice!

---

## **Version 3 (knapsack_v3.py) - Memoization**

```
                maxVal(0, C=100)
                /              \
          skip item 0      take item 0
        maxVal(1, C=100)   maxVal(1, C=80)  [w[0]=20]
           /      \            /         \
       skip 1   take 1     skip 1     take 1
    maxVal(2,100) maxVal(2,70)  maxVal(2,80) maxVal(2,50)
         ↓           ↓             ↓            ↓
      CACHED!     CACHED!       CACHED!      CACHED!

memo = {
  (0, 100): 150,
  (1, 100): 120,
  (1, 80): 100,
  (2, 100): 90,
  (2, 80): 70,
  (2, 70): 60,
  (2, 50): 50,
  ...
}

When maxVal(2, 100) is called again → return memo[(2, 100)] immediately!
```

### How Memoization Works:

1. **First call** to `maxVal(i, C)`:
   - Check if `(i, C)` is in memo → NO
   - Compute the result recursively
   - Store result: `memo[(i, C)] = result`
   - Return result

2. **Subsequent calls** to same `maxVal(i, C)`:
   - Check if `(i, C)` is in memo → YES
   - Return `memo[(i, C)]` immediately (no recursion!)

### Key Insight:
- First time `maxVal(i, C)` is called → compute result, store in `memo[(i, C)]`
- Next time `maxVal(i, C)` is called → return cached result from memo
- **Calls**: At most O(N × M) unique states
- **Speedup**: From exponential to polynomial!

---

## **Comparison Table:**

| Version | States Generated | Function Calls | Time Complexity |
|---------|-----------------|----------------|-----------------|
| v1 | All 2^N combinations | 2^(N+1) - 1 | O(2^N) |
| v2 | Many repeated (i,C) | ~2^N (with pruning) | O(2^N) |
| v3 | Each (i,C) once | ≤ N×M + overhead | O(N×M) |

**Example with N=20, M=1000:**
- v2: ~1,000,000+ calls (many duplicates)
- v3: ~20,000 calls maximum (each state computed once)

---

## **Questions & Answers:**

### Q5: Is each state generated by the brute-force algorithm unique?

**NO.** The brute-force algorithm (v2) generates many repeated states. The same `(i, C)` pair can be reached through different decision paths (different sequences of taking/skipping items).

### Q6: Given a problem state, does any recursive call on this state return the same value?

**YES.** For a given state `(i, C)`, the function `maxVal(i, C)` will always return the same value because:
- The function is deterministic (no randomness)
- It only depends on the input parameters `i` and `C`
- The arrays `w` and `v` are constant throughout execution

This property makes the problem suitable for memoization!

### Q8: How to compare recursive calls?

Run the programs with the same input and check the "function calls:" output:

```bash
python3 knapsack_v2.py < knapsacktests/knapsack4.in
python3 knapsack_v3.py < knapsacktests/knapsack4.in
```

You should see a dramatic reduction in function calls with memoization!

---

## **Dictionary with Tuples (memo implementation):**

Python dictionaries can use tuples as keys:

```python
memo = {}
memo[(0, 100)] = 50   # key is tuple (i=0, C=100), value is 50

# Checking if a key exists
if (0, 100) in memo:
    result = memo[(0, 100)]  # Fast lookup: O(1)
```

**Why tuples work as dictionary keys:**
- Tuples are **immutable** (can't be changed after creation)
- Tuples are **hashable** (Python can compute a hash value)
- This makes them valid dictionary keys

**Alternative: 2D List**
```python
memo = [[-1]*(M+1) for _ in range(N+1)]  # -1 means not computed
if memo[i][C] != -1:
    return memo[i][C]
```

Both approaches work, but:
- **Dictionary**: More flexible, only stores computed states
- **2D List**: Faster access, uses more memory (pre-allocates all states)
